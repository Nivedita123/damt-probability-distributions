import java.util.*;

public class Distribution {

	Random r;

	public Distribution(Long seed) {

		if (seed == null) {
			this.r = new Random();
		} else {
			this.r = new Random(seed);
		}
	}

	/*
	 * A random variable with two possible values, 0 and 1, is called a Bernoulli
	 * variable, its distribution is Bernoulli distribution
	 */
	public List<Integer> generateBernoulli(int samples, double p) {

		List<Integer> res = new ArrayList<Integer>();

		for (int i = 0; i < samples; i++) {

			if (r.nextDouble() < p) {
				res.add(1);
			} else {
				res.add(0);
			}
		}
		return res;
	}

	/*
	 * A variable described as the number of successes in a sequence of independent
	 * Bernoulli trials has Binomial distribution
	 */
	public List<Integer> generateBinomial(int samples, int n, double p) {

		List<Integer> res = new ArrayList<Integer>();

		for (int i = 0; i < samples; i++) {

			List<Integer> bernouliTrials = generateBernoulli(n, p);

			res.add(Collections.frequency(bernouliTrials, 1));

		}
		return res;

	}

	/*
	 * The number of Bernoulli trials needed to get the first success has Geometric
	 * distribution.
	 * 
	 */
	public List<Integer> generateGeometric(int samples, double p) {

		List<Integer> res = new ArrayList<Integer>();

		for (int i = 0; i < samples; i++) {

			int j = 1;
			while (generateBernoulli(1, p).get(0) == 0) {
				j++;
			}
			res.add(j);
		}

		return res;
	}

	/*
	 * In a sequence of independent Bernoulli trials, the number of trials needed to
	 * obtain k successes has Negative Binomial distribution.
	 */
	public List<Integer> generateNegBinomial(int samples, int k, double p) {

		List<Integer> res = new ArrayList<Integer>();

		for (int i = 0; i < samples; i++) {

			int j = 1;
			int success = 0;
			while (success < k) {

				j++;

				if (generateBernoulli(1, p).get(0) == 1) {
					success++;
				}
			}
			res.add(j);
		}

		return res;

	}

	/*
	 * The number of rare events occurring within a fixed period of time has Poisson
	 * distribution.
	 */

	public List<Integer> generatePoisson(int samples, int lambda) {

		List<Integer> res = new ArrayList<Integer>();

		for (int i = 0; i < samples; i++) {

			double F = Math.exp(-lambda);
			double u = r.nextDouble();
			int k = 0;

			while (u >= F) {
				k++;
				u = r.nextDouble();
			}

			res.add(k);
		}

		return res;
	}

	/* any arbitrary discrete distribution */
	public List<Integer> generateArbDiscrete(int samples, List<Double> p) {

		List<Integer> res = new ArrayList<Integer>();

		// generate intervals from p[]
		List<Double> F = new ArrayList<Double>();
		F.add(p.get(0));
		for (int i = 1; i < p.size(); i++) {

			F.add(F.get(i - 1) + p.get(i));

		}

		for (int i = 0; i < samples; i++) {

			// generate uniform variable
			double u = r.nextDouble();
			int k = 0;

			while (F.get(k) <= u) {
				k++;
			}
			res.add(k);

		}
		return res;

	}

	/*
	 * value is picked "at random" from a given interval; that is, without any
	 * preference to lower, higher, or medium values.
	 */
	public List<Double> generateUniform(int samples, double min, double max) {

		List<Double> res = new ArrayList<Double>();

		// ensure min < max
		if (min > max) {
			double temp = max;
			max = min;
			min = temp;
		}

		for (int i = 0; i < samples; i++) {

			// the random numbers generated by Java are uniformly distributed in the range
			// (0,1), hence changing the range to (min, max)
			double x = min + (r.nextDouble() * (max - min));
			res.add(x);
		}
		return res;
	}

	/* Times between rare events are Exponentially distributed */
	public List<Double> generateExponential(int samples, double lambda) {

		List<Double> res = new ArrayList<Double>();

		for (int i = 0; i < samples; i++) {

			// uniform variable
			double u = r.nextDouble();

			// exponential variable
			double X = -(1 / lambda) * Math.log(1 - u);
			res.add(X);
		}
		return res;
	}

	/*
	 * When a certain procedure consists of alpha independent steps, and each step
	 * takes Exponential(lambda) amount of time, then the total time has Gamma
	 * distribution with parameters alpha and lambda.
	 */
	public List<Double> generateGamma(int samples, int alpha, double lambda) {

		List<Double> res = new ArrayList<Double>();

		for (int i = 0; i < samples; i++) {

			// alpha number of exp samples
			List<Double> exp = generateExponential(alpha, lambda);
			double expSum = 0;

			// sum of exp samples
			for (int j = 0; j < exp.size(); j++) {
				expSum += exp.get(j);
			}
			res.add(expSum);
		}
		return res;
	}

	// represents the distribution of many random variables as a symmetrical
	// bell-shaped graph.
	public List<Double> generateNormal(int samples, double mu, double sigma) {

		List<Double> res = new ArrayList<Double>();

		// take ceiling value of number of samples required, since each iteration
		// generates 2 samples
		for (int i = 0; i <= samples / 2; i++) {

			// uniform variables in range(0, 1)
			double u1 = r.nextDouble();
			double u2 = r.nextDouble();

			// standard normal variables (Box - Muller transformation) with mean = 0 and
			// std. deviation = 1
			double z1 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
			double z2 = Math.sqrt(-2 * Math.log(u1)) * Math.sin(2 * Math.PI * u2);

			// normal variables with mean = mu and std. deviation = sigma
			res.add(z1 * sigma + mu);
			res.add(z2 * sigma + mu);

		}

		return res;
	}
}
